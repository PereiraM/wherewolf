<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 12px sans-serif;
}

path {
  stroke-width: 1px;
  stroke: white;
  fill: #ddd;
  cursor: pointer;
}

circle {
  opacity: 0.6;
  fill: #666;
  stroke: none;
  cursor: pointer;
}

circle:hover {
  opacity: 1;
  stroke: black;
  stroke-width: 1px;
}

svg {
  margin-left: auto;
  margin-right: auto;
}

div.container {
  width: 600px;
  margin-left: auto;
  margin-right: auto;
}

div.info {
  font-weight: bold;
  font-size: 24px;
  padding: 12px;
  text-align: center;
}

pre, code {
  font-family: "Menlo", monospace;
  white-space: pre;
  font-size: 18px;
}

pre {
  background-color: #eee;
  padding: 12px;
}

</style>
<body>
<div class="container">
  <div class="map"></div>
  <div class="info"></div>
  <div class="result">
    <pre><code>Mouse over a dot</code></pre>
  </div>
</div>
<script src="topojson.v1.min.js"></script>
<script src="d3.v3.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
<script src="boundless.js"></script>
<script>

//Map dimensions (in pixels)
var benchmarks = new Benchmarks(),
    width = 600,
    height = 349,
    info = d3.select("div.info"),
    result = d3.select("code");
    projection = d3.geo.albers()
      .scale(730.3062176506113)
      .translate([width/2,height/2]),
    path = d3.geo.path()
    .projection(projection),
    svg = d3.select("div.map").append("svg")
    .attr("width", width)
    .attr("height", height),
    features = svg.append("g")
      .attr("class","features"),
    colors = ["#ff0","#0ff","#0f0","#f0f"];

benchmarks.start("Extra loading time");

d3.json("us-states-counties.topojson",function(err,geodata) {

  benchmarks.stop("Extra loading time");

  benchmarks.start("Time to prep features for search");

  var bl = new Boundless();

  bl.addAll(geodata);

  benchmarks.stop("Time to prep features for search");

  //Create a path for each map feature in the data
  features.selectAll("path")
    .data(topojson.feature(geodata,geodata.objects.state))
    .enter()
    .append("path")
    .attr("d",path);

  var bounds = pad(d3.geo.bounds(topojson.feature(geodata,geodata.objects.state)));

  var points = d3.range(5000).map(function(){
    return [
      bounds[0][0]+Math.random()*(bounds[1][0]-bounds[0][0]),
      bounds[0][1]+Math.random()*(bounds[1][1]-bounds[0][1]),
    ]
  });

  points = points.map(function(p){

    var proj = projection(p);

    return {
      "x": proj[0],
      "y": proj[1],
      "lat": p[1],
      "lng": p[0]
    };

  });

  benchmarks.start("Time to check 5000 lat/lngs");

  points = points.map(function(p){

    p.found = bl.find([p.lng,p.lat]);

    return p;

  });

  benchmarks.stop("Time to check 5000 lat/lngs");

  var colorsByName = {};

  features.selectAll("circle")
    .data(points)
    .enter()
    .append("circle")
      .attr("r",3)
      .attr("cx",function(d){
        return d.x;
      })
      .attr("cy",function(d){
        return d.y;
      })
      .on("mouseover",function(d){
        result.text(JSON.stringify(d.found,null,"  "));
      })
      .filter(function(d){
        return d.found.state;
      })
        .style("fill",function(d){

          if (!colorsByName[d.found.state.name]) {
            var c = colors.pop();
            colorsByName[d.found.state.name] = c;
            colors.unshift(c);
          }

          return colorsByName[d.found.state.name];

        });


  console.log(benchmarks.list());

});

function now() {
  return 
}

function pad(b) {
  var wx = (b[1][0]-b[0][0]) * 0.1,
      hx = (b[1][1]-b[0][1]) * 0.1;

  console.log([
    [
      b[0][0]-wx,
      b[0][1]-hx
    ],
    [
      b[1][0]+wx,
      b[1][1]+hx
    ]
  ]);

  return [
    [
      b[0][0]-wx,
      b[0][1]-hx
    ],
    [
      b[1][0]+wx,
      b[1][1]+hx
    ]
  ];

}

function Benchmarks() {
  var marks = {};

  return {
    "start": function(key){
      marks[key] = (new Date()).getTime();
    },
    "stop": function(key){
      marks[key] = (new Date()).getTime() - marks[key];
    },
    "list": function(){
      return marks;
    }
  };
}

</script>