<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 12px sans-serif;
}

path {
  stroke-width: 1px;
  stroke: #999;
  fill: none;
  cursor: pointer;
}

circle {
  opacity: 0.6;
  fill: #666;
  stroke: none;
  cursor: pointer;
}

circle:hover {
  opacity: 1;
  stroke: black;
  stroke-width: 1px;
}

svg {
  margin-left: auto;
  margin-right: auto;
}

div.container {
  width: 600px;
  margin-left: auto;
  margin-right: auto;
}

div.info {
  font-size: 16px;
  padding: 12px 0;
}

pre, code {
  font-family: "Menlo", monospace;
  white-space: pre;
  font-size: 18px;
}

pre {
  background-color: #eee;
  padding: 12px;
  margin: 0;
}

</style>
<body>
<div class="container">
  <div class="map"></div>
  <div class="info"></div>
  <div class="result">
    <pre><code>Mouse over a dot</code></pre>
  </div>
</div>
<script src="topojson.v1.min.js"></script>
<script src="d3.v3.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
<script src="wherewolf.js"></script>
<script>

//Map dimensions (in pixels)
var benchmarks = new Benchmarks(),
    width = 600,
    height = 349,
    info = d3.select("div.info"),
    result = d3.select("code");
    projection = d3.geo.albers()
      .scale(730.3062176506113)
      .translate([width/2,height/2]),
    path = d3.geo.path()
    .projection(projection),
    svg = d3.select("div.map").append("svg")
    .attr("width", width)
    .attr("height", height),
    features = svg.append("g")
      .attr("class","features"),
    colors = ["#ff0","#0ff","#0f0","#f0f"];

benchmarks.start("Extra loading time");

d3.json("lower48-with-holes.geojson",function(err,geodata) {

  benchmarks.stop("Extra loading time");

  benchmarks.start("Time to prep features for search");

  var ww = new Wherewolf();

  ww.add("state",geodata);

  benchmarks.stop("Time to prep features for search");

  var bg = geodata.type == "Topology" ? topojson.feature(geodata,geodata.objects.state) : geodata;

  //Create a path for each map feature in the data
  features.selectAll("path")
    .data(bg.features)
    .enter()
    .append("path")
    .attr("d",path);

  var bounds = pad(d3.geo.bounds(bg));

  var points = d3.range(2000).map(function(){
    return [
      bounds[0][0]+Math.random()*(bounds[1][0]-bounds[0][0]),
      bounds[0][1]+Math.random()*(bounds[1][1]-bounds[0][1]),
    ]
  });

  points = points.map(function(p){

    var proj = projection(p);

    return {
      "x": proj[0],
      "y": proj[1],
      "lat": p[1],
      "lng": p[0]
    };

  });

  benchmarks.start("Time to check 2000 lat/lngs");

  points = points.map(function(p){

    p.found = ww.find([p.lng,p.lat],{wholeFeature:true,layer:"state"});

    return p;

  });

  benchmarks.stop("Time to check 2000 lat/lngs");

  var colorsByName = {};

  features.selectAll("circle")
    .data(points)
    .enter()
    .append("circle")
      .attr("r",3)
      .attr("cx",function(d){
        return d.x;
      })
      .attr("cy",function(d){
        return d.y;
      })
      .on("mouseover",function(d){
        result.text(JSON.stringify(d.found,null,"  "));
      })
      .filter(function(d){
        return d.found && (d.found.state || d.found.name || d.found.properties.name);
      })
        .style("fill",function(d){
          var name;
          if (d.found.name) {
            name = d.found.name;
          } else if (d.found.state) {
            if (d.found.state.properties) {
              name = d.found.state.properties.name;
            } else {
              name = d.found.state.name;
            }
          } else {
            name = d.found.properties.name;
          }

          if (!colorsByName[name]) {
            var c = colors.pop();
            colorsByName[name] = c;
            colors.unshift(c);
          }

          return colorsByName[name];

        });

  info.selectAll("div")
    .data(d3.entries(benchmarks.list()))
    .enter()
    .append("div")
      .html(function(d){
        return "<strong>"+d.key+": </strong> "+d.value+"ms";
      });

});

function now() {
  return 
}

function pad(b) {
  var wx = (b[1][0]-b[0][0]) * 0.05,
      hx = (b[1][1]-b[0][1]) * 0.05;

  return [
    [
      b[0][0]-wx,
      b[0][1]-hx
    ],
    [
      b[1][0]+wx,
      b[1][1]+hx
    ]
  ];

}

function Benchmarks() {
  var marks = {};

  return {
    "start": function(key){
      marks[key] = (new Date()).getTime();
    },
    "stop": function(key){
      marks[key] = (new Date()).getTime() - marks[key];
    },
    "list": function(){
      return marks;
    }
  };
}

</script>