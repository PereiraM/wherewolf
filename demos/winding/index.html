<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700,900" type="text/css">
    <style>

      body {
        background-color: #fff;
        color: #000;
        padding: 0;
        margin: 0;
        font-size: 14px;
        font-family: "Lato", helvetica, verdana, arial, sans-serif;
        -moz-text-size-adjust: none;
        -webkit-text-size-adjust: none;
        -ms-text-size-adjust: none;
      }

      svg {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        cursor: pointer;
      }

      div.click-me {
        position: fixed;
        z-index: 11;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255,255,255,0.45);
        pointer-events: none;
      }

      div.table {
        display: table;
        height: 100%;
        width: 100%;
      }

      div.cell {
        display: table-cell;
        vertical-align: middle;
        text-align: center;
        font-size: 72px;
        font-weight: bold;
      }

      circle,
      line,
      path,
      text,
      rect {
        pointer-events: none;
      }

      text.count {
        font-size: 32px;
        font-weight: bold;
        text-anchor: start;
      }

      text.status {
        font-size: 44px;
        font-weight: bold;
        text-anchor: start;
        fill: #da1c5c;
      }

      g.background path {
        stroke: #444;
        stroke-width: 2px;
        fill: rgba(0,0,0,0.2);
      }

      g.background.off path {
        fill: rgba(0,0,0,0.05);
        stroke-width: 1px;
        stroke: #999;
      }

      g.foreground line {
        fill: none;
        stroke-width: 2px;
      }

      g.intersections path {
        stroke-width: 2px;
        stroke-linecap: round;
      }

      g.foreground circle,
      g.sticky circle,
      g.arrowhead path,
      g.intersections circle {
        stroke: none;
      }

      g.arrowhead path,
      g.intersections circle,
      g.foreground circle,
      text.status {
        fill: #666;
      }

      g.sticky circle {
        fill: dodgerblue;
      }

      g.intersections path,
      g.foreground line {
        stroke: #666;
      }

      body.outside g.arrowhead path,
      body.outside g.intersections circle,
      body.outside g.foreground circle,
      body.outside g.sticky circle,
      body.outside text.status {
        fill: #da1c5c;
      }

      body.outside g.intersections path,
      body.outside g.foreground line {
        stroke: #da1c5c;
      }

      body.inside g.arrowhead path,
      body.inside g.intersections circle,
      body.inside g.foreground circle,
      body.inside g.sticky circle,
      body.inside text.status {
        fill: #169d8e;
      }

      body.inside g.intersections path,
      body.inside g.foreground line {
        stroke: #169d8e;
      }

      g.sticky text {
        font-size: 20px;
        font-weight: bold;
        fill: black;
        text-anchor: middle;
      }

      .hidden {
        display: none;
      }

    </style>
    <title>PIP Demo</title>
  </head>
  <body>
    <div class="click-me"><div class="table"><div class="cell">Loading...</div></div></div>
    <script src="../d3.v3.min.js"></script>
    <script>
      var width = 800,
          height = 500,
          clickMe = d3.select("div.click-me"),
          pending = false,
          svg = d3.select("body")
                  .append("svg")
                  .attr("viewBox","0 0 "+width+" "+height)
                  .attr("preserveAspectRatio","xMidYMid meet");

      var parameters = {
        MD: {
          scale: 8800,
          center: [-77.268295,38.82313944121967]
        }
      }

      //Map projection
      var projection = d3.geo.mercator()
          .scale(parameters.MD.scale)
          .center(parameters.MD.center) //projection center
          .translate([width/2,height/2]); //translate to center the map in view

      //Generate paths based on projection
      var path = d3.geo.path()
          .projection(projection);

      d3.json("../maryland.json",function(err,data){

        var background = svg.append("g").attr("class","background");

        background.append("path").attr("d",function(d){
            //raw function, prevent interpolation
            return "M"+data.features[0].geometry.coordinates[0].map(function(ll){return projection(ll);}).join("L");
        });

        var arcs = getArcs(data.features[0]);

        var count = svg.append("text").attr("class","count").attr("x",75).attr("y",height-140);

        var status = svg.append("text").attr("class","status").attr("x",75).attr("y",height-90);

        var intersections = svg.append("g").attr("class","intersections"),
            foreground = svg.append("g").attr("class","foreground"),
            clicked = foreground.append("circle").attr("r",8).attr("cx",-9999).attr("cy",-9999),
            line = foreground.append("line"),
            arrowhead = foreground.append("g").attr("class","arrowhead").attr("transform","translate("+width+")").append("path").attr("d","M0,0L-10,-5L-10,5Z").attr("transform","translate(0 -20)"),
            sticky = svg.append("g").attr("class","sticky"),
            totalLength = background.select("path").node().getTotalLength();

        clickMe.on("click",function(){
          d3.select(this).remove();
        });

        svg.on("click",function(){

          var xy = d3.mouse(this);
          var p = projection.invert(xy);

          clickMe.remove();

          if (pending) {
            return true;
          }

          pending = true;

          intersections.selectAll("g").remove();
          sticky.selectAll("g").remove();

          background.classed("off",true);

          line.attr("x1",xy[0])
             .attr("x2",width-5)
             .attr("y1",xy[1])
             .attr("y2",xy[1]);

          d3.select("body").attr("class",null);
          count.text("w = 0");
          status.text("");

          arrowhead.attr("transform","translate(0 "+xy[1]+")");

          clicked.attr("cx",xy[0])
             .attr("cy",xy[1]);

          var mapped = arcs.map(function(d){

            var w = getWinding(xy,projection(d[0]),projection(d[1]));

            var i = [null,null];

            if (w) {
              i = yIntersection(projection(d[0]),projection(d[1]),xy[1]);
            }

            return {
              "arc": d,
              "x": i[0],
              "y": i[1],
              "w": w
            };

          })

          var segments = intersections.selectAll("g")
            .data(mapped)
            .enter()
            .append("g")
              .attr("class",function(d){
                return d.w !== 0 ? "intersects" : "not-intersects";
              });

          segments.append("path")
            .attr("d",function(d){
              return "M"+projection(d.arc[0]).join(",")+"L"+projection(d.arc[1]).join(",");
            })
            .style("stroke","#f0f")
            .style("stroke-opacity",0);

          var runningLength = 0;

          segments.each(function(d){
            d.length = d3.select(this).select("path").node().getTotalLength();
            d.lengthBefore = runningLength;
            d3.select(this).datum(d);
            runningLength += d.length;
          });

          var filtered = segments.data().filter(function(d){
            return d.w !== 0;
          });

          var labels = sticky.selectAll("g")
            .data(filtered)
            .enter()
            .append("g")
              .attr("class","hidden");

          labels.append("circle")
            .attr("r",4)
            .attr("cx",function(d){
              return d.x;
            })
            .attr("cy",function(d){
              return d.y;
            });

          labels.append("text")
              .attr("x",function(d){
                return d.x;
              })
              .attr("y",function(d){
                return d.y;
              })
              .attr("dy",function(d){
                if (d.w < 0) {
                  return "22px";
                } else {
                  return "-8px";
                }
              })
              .text(function(d){
                return d.w > 0 ? "+1" : d.w;
              });

          var runningW = 0;

          segments.transition()
            .duration(function(d){
              return d.length*2;
            })
            .delay(function(d,i){
              return d.lengthBefore*2;
            })
            .each("end",function(d,i){
              d3.select(this).select("path").style("stroke",d.w ? "dodgerblue" : "#666");
              if (d.w) {
                d3.select("g.hidden").classed("hidden",false);
              }
              d3.select(this).selectAll("text,circle").style("display","block");

              if (d.w) {
                runningW += d.w;
                count.text("w = "+runningW);
              }

              if (i === mapped.length - 1) {
                d3.selectAll("g.not-intersects path").style("stroke-opacity",0);
                d3.selectAll("g.intersects path").style("stroke",null);
                d3.select("body").attr("class",runningW !== 0 ? "inside" : "outside");

                status.text(runningW === 0 ? "OUTSIDE " : "INSIDE");
                d3.selectAll("g.sticky path").style("stroke",null);
                pending = false;
              }

            })
            .select("path")
              .style("stroke-opacity",1);

        });

        clickMe.select("div.cell").text("CLICK ME");

      });

      function yIntersection(p0,p1,y) {

        //Crude y-intersection for display purposes
        //Prevent divide by zero
        if (p0[1] === p1[1]) {
          return [(p0[0]+p1[0])/2,p[0][1]]
        }

        if (p0[0] === p1[0]) {
          return [p0[0],y];
        }

        var m = (p0[1]-p1[1])/(p0[0]-p1[0]),
            b = p1[1]-(m*p1[0]);

        return [(y-b)/m,y];

      }

      function getArcs(feature) {

        var rings,
            arcs = [];

        if (feature.geometry.type == "Polygon") {
          rings = [feature.geometry.coordinates[0]];
        } else {
          rings = feature.geometry.coordinates.map(function(poly){
            return poly[0];
          });
        }

        rings.forEach(function(vs){

          for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {

              arcs.push([vs[i],vs[j]]);

          }

        });

        return arcs;

      }

      function intersect(point,a,b) {

        var x = point[0], y = point[1];
        var xi = a[0], yi = a[1];
        var xj = b[0], yj = b[1];

        return ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

      }

      function dir(v1,v2,p) {
        return (v2[0] - v1[0]) * (p[1] - v1[1]) - (p[0] -  v1[0]) * (v2[1] - v1[1])
      }

      function isLeft(v1,v2,p) {
          return dir(v1,v2,p) > 0;
      }

      function isRight(v1,v2,p) {
        return dir(v1,v2,p) < 0;
      }

      function getWinding(point,a,b) {

        if (a[1] <= point[1]) {
          if (b[1] > point[1] && isLeft(a,b,point)) {
            return 1;
          }
        } else if (b[1] <= point[1] && isRight(a,b,point)) {
          return -1;
        }

        return 0;

      }

    </script>
  </body>
</html>